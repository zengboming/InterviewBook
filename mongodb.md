基于分布式文件存储的开源数据库系统。

	MongoDB 将数据存储为一个文档，数据结构由键值\(key=&gt;value\)对组成。

	数据库 database     

	集合   collection  相当于表

	文档   document    相当于行   文档中的键/值对是有序的。

	字段   field       相当于列



	slaveOk=true\|false：

	true: 在connect=replicaSet模式下，驱动会发送所有的写请求到主并且把读取操作分布在其他从服务器。

	false:在connect=replicaSet 模式下，驱动仅仅连接主服务器，并且所有的读写命令都连接到主服务器。



	AND:  db.col.find\({key1:value1, key2:value2}\).pretty\(\)

	OR:   db.col.find\({$or: \[{key1: value1}, {key2:value2}\]}\).pretty\(\)



	副本集群：

	主节点，负责处理客户端请求。从节点，负责复制主节点上的数据。主节点与从节点进行数据交互保障数据的一致性。

	任何节点可作为主节点、所有写入操作都在主节点上、自动故障转移、自动恢复。

	主从在主机宕机后所有服务将停止，而副本集在主机宕机后，副本会接管主节点成为主节点，不会出现宕机的情况。

	仲裁节点是一种特殊的节点，它本身并不存储数据，主要的作用是决定哪一个备节点在主节点挂掉之后提升为主节点



	分片集群：

	shard：用于存储实际的数据块。一个shard server角色可由几台机器组个一个replica set承担，防止主机单点故障。

	Config Server:mongod实例，存储了整个 ClusterMetadata，其中包括 chunk信息。

	Query Routers:前端路由，客户端由此接入，且让整个集群看上去像单一数据库，前端应用可以透明使用。

	需要一个仲裁节点，还需要配置节点和路由节点。



	优化：

	1.范式化与反范式化

		a\) 完全分离\(范式化设计\)		增删改较多，查询较少

		b\) 完全内嵌\(反范式化设计\)	查询多，修改少

		c\) 部分内嵌\(折中方案\)       既保证了查询效率，也保证的更新效率

	2.理解填充因子

		填充因子是MongoDB为文档的扩展而预留的增长空间。文档的移动非常消耗性能，频繁的移动会大大增加系统的负担。最有可能会让文档体积变大的因素是数组。

		a\) 增加初始分配空间。

			在集合的属性中包含一个 usePowerOf2Sizes 属性，当这个选项为true时，系统会将后续插入的文档，初始空间都分配为2的N次方。

			这种分配机制适用于一个数据会频繁变更的集合使用。但这种分配方式会导致写入速度相对变慢。

		b\) 我们可以利用数据强行将初始分配空间扩大。

			添加一个字段，初始化很长的内容，将来删减。

	3.准确利用索引

		如果一个查询命令进入到数据库中后，查询优化器没有找到合适的索引，那么数据库会进行全集合扫描\(在RDBMS中也叫全表扫描\)，全集合查询对于性能的影响是灾难性的。

		a\) 索引越少越好

			每当你建立一个索引时，系统会为你添加一个索引表，对已建立索引的列修改，索引重新排序消耗大。在可以满足索引需求的情况下，索引的数量越少越好。

			1\) 隐式索引: 如果我们想要排序的字段包含在已建立的复合索引中则无需重复建立索引。

			2\) 翻转索引：

		b\) 索引列颗粒越小越好

			在索引列中每个数据的重复数量称为颗粒，也叫作索引的基数。如果数据的颗粒过大，索引就无法发挥该有的性能。

	4.分片均匀/读写分离/避免不带片键查询/避免过长的字段名/避免文档无限的增长/避免过大文档



	mongoDB与mysql区别：

		a\) 弱一致性，高速

 		b\) 文档存储

		c\) 易扩展

		d\) 分布式文件系统，支持海量数据存储

		e\) 没有事务

		f\) 高可用：可以快速、安全及自动化的实现节点故障转移

	mongodb不支持事务



