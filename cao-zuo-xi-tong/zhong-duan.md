# 死锁

是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。

#### 产生死锁的原因

（1）竞争系统资源 （2）进程的推进顺序不当

#### 死锁的四个条件

1. **互斥条件**：指进程对所分配到的资源进行排它性使用，即在**一段时间内某资源只由一个进程占用**。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放
2. **请求和保持条件**：指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时**请求进程阻塞，但又对自己已获得的其它资源保持不放。**
3. **不剥夺条件**：指**进程已获得的资源，在未使用完之前，不能被剥夺**，只能在使用完时由自己释放。
4. **环路等待条件**：指**在发生死锁时，必然存在一个进程资源的环形链**，即进程集合{P0，P1，P2，···，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源。

#### 处理死锁的方法

1. 预防死锁。
   这是一种较简单和直观的事先预防的方法。方法是通过设置某些限制条件，去破坏产生死锁的四个必要条件中的一个或者几个，来预防发生死锁。预防死锁是一种较易实现的方法，已被广泛使用。但是由于所施加的限制条件往往太严格，可能会导致系统资源利用率和系统吞吐量降低。
   1. 资源一次性分配：（破坏请求和保持条件）
   2. 可剥夺资源：即当某进程新的资源未满足时，释放已占有的资源（破坏不可剥夺条件）
   3. 资源有序分配法：系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反（破坏环路等待条件）
   4. 允许某些进程\(线程\)同时访问某些资源，但有的资源不允许同时被访问如打印机等（破坏互斥性条件）
2. 避免死锁。
   该方法同样是属于事先预防的策略，但它并不须事先采取各种限制措施去破坏产生死锁的的四个必要条件，而是在资源的动态分配过程中，用某种方法去防止系统进入不安全状态，从而避免发生死锁。
   1. 安全序列:虽然存在安全序列时一定不会有死锁发生，但是系统进入不安全状态（四个死锁的必要条件同时发生）也未必会产生死锁
   2. 银行家算法：该算法需要检查申请者对资源的最大需求量，如果系统现存的各类资源可以满足申请者的请求，就满足申请者的请求。这样申请者就可很快完成其计算，然后释放它占用的资源，从而保证了系统中的所有进程都能完成，所以可避免死锁的发生
3. 检测死锁。
   这种方法并不须事先采取任何限制性措施，也不必检查系统是否已经进入不安全区，此方法允许系统在运行过程中发生死锁。但可通过系统所设置的检测机构，及时地检测出死锁的发生，并精确地确定与死锁有关的进程和资源，然后采取适当措施，从系统中将已发生的死锁清除掉。
   1. 首先为每个进程和每个资源指定一个唯一的号码；然后建立资源分配表和进程等待表
4. 解除死锁。  
   一旦检测出死锁，就应立即釆取相应的措施，以解除死锁。

   1. 剥夺资源：从其它进程剥夺足够数量的资源给死锁进程，以解除死锁状态；
   2. 撤消进程：可以直接撤消死锁进程或撤消代价最小的进程，直至有足够的资源可用，死锁状态.消除为止
   3. 回退进程：让一（多）个进程回退到足以回避死锁的地步，进程回退时自愿释放资源而不是被剥夺。要求系统保持进程的历史信息，设置还原点。



