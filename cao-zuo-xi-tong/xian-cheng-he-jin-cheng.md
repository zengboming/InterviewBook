# 线程和进程

#### 进程

进程是一个具有独立功能的程序关于某个数据集合的一次运行活动。它可以申请和拥有系统资源，是一个动态的概念，是一个活动的实体。它不只是程序的代码，还包括当前的活动，通过程序计数器的值和处理寄存器的内容来表示。

1. 进程是一个实体。每一个进程都有它自己的地址空间，一般情况下，包括文本区域（text region）、数据区域（data region）和堆栈（stack region）。文本区域存储处理器执行的代码；数据区域存储变量和进程执行期间使用的动态分配的内存；堆栈区域存储着活动过程调用的指令和本地变量。

2. 进程是一个“执行中的程序”。程序是一个没有生命的实体，只有处理器赋予程序生命时，它才能成为一个活动的实体，我们称其为进程。

**进程的基本状态**：

1. 等待态：等待某个事件的完成；
2. 就绪态：等待系统分配处理器以便运行；
3. 运行态：占有处理器正在运行。

**进程调度**

1. 高级调度：\(High-Level Scheduling\)又称为作业调度，它决定把后备作业调入内存运行；
2. 中级调度：\(Intermediate-Level Scheduling\)又称为在虚拟存储器中引入，在内、外存对换区进行进程对换。
3. 低级调度：\(Low-Level Scheduling\)又称为进程调度，它决定把就绪队列的某进程获得CPU；

**非抢占式调度与抢占式调度**

1. 非抢占式：分派程序一旦把处理机分配给某进程后便让它一直运行下去，直到进程完成或发生进程调度进程调度某事件而阻塞时，才把处理机分配给另一个进程。

2. 抢占式：操作系统将正在运行的进程强行暂停，由调度程序将CPU分配给其他就绪进程的调度方式。

**进程调度算法**

1. FIFO或First Come, First Served \(FCFS\)

   调度的顺序就是任务到达就绪队列的顺序。公平、简单\(FIFO队列\)、非抢占、不适合交互式。未考虑任务特性，平均等待时间可以缩短。

2. Shortest Job First \(SJF\)

   最短的作业\(CPU区间长度最小\)最先调度。SJF可以保证最小的平均等待时间。

3. 优先权调度

   每个任务关联一个优先权，调度优先权最高的任务。优先权太低的任务一直就绪，得不到运行，出现“饥饿”现象。这些调度算法都不适合于交互式系统。

4. Round-Robin\(RR\)

   设置一个时间片，按时间片来轮转调度（“轮叫”算法）。优点: 定时有响应，等待时间较短；缺点: 上下文切换次数较多。

5. 多级队列调度

   按照一定的规则建立多个进程队列，不同的队列有固定的优先级（高优先级有抢占权），不同的队列可以给不同的时间片和采用不同的调度方法。存在问题：没法区分I/O bound和CPU bound；也存在一定程度的“饥饿”现象。

6. 多级反馈队列

   在多级队列的基础上，任务可以在队列之间移动，更细致的区分任务。可以根据“享用”CPU时间多少来移动队列，阻止“饥饿”。最通用的调度算法，多数OS都使用该方法或其变形，如UNIX、Windows等。

#### 线程

多进程解决了多任务问题。然而很多时候不同的程序需要共享同样的资源（文件，信号量等），如果全都使用进程的话会导致切换的成本很高，造成 CPU 资源的浪费。于是就出现了线程的概念。

线程，有时被称为轻量级进程\(Lightweight Process，LWP），是程序执行流的最小单元。一个标准的线程由线程ID，当前指令指针\(PC），寄存器集合和堆栈组成。

#### 进程和线程的区别

1. 进程是资源的分配和调度的一个独立单元，而线程是CPU调度的基本单元
2. 同一个进程中可以包括多个线程，并且线程共享整个进程的资源（寄存器、堆栈、上下文），一个进程至少包括一个线程。
3. 进程结束后它拥有的所有线程都将销毁，而线程的结束不会影响同个进程中的其他线程的结束
4. 一个进程无法直接访问另一个进程的资源；同一进程内的多个线程共享进程的资源。
5. 线程中执行时一般都要进行同步和互斥，因为他们共享同一进程的所有资源
6. 创建进程的开销大，包括创建虚拟地址空间等需要大量系统资源；创建线程开销小，基本上只有一个内核对象和一个堆栈。
7. 进程切换开销大，线程切换开销小；进程间通信开销大，线程间通信开销小。



