# 内存管理

#### JVM内存结构

1. 堆
2. 栈
3. 方法区
4. 本地方法栈
5. 程序计数器

#### 堆

* 堆内存在虚拟机启动时创建，堆内存用来存放由 new 创建的对象和数组，在堆中分配的内存，由 Java 虚拟机的自动垃圾回收器来管理。
* 堆内存是所有**线程共享**的一块内存。
* 在堆中产生了一个数组或者对象之后，还可以在栈中定义一个特殊的变量，让栈中的这个变量的取值等于数组或对象在堆内存中的首地址，栈中的这个变量就成了数组或对象的引用变量。引用变量是普通的变量，定义时在栈中分配，引用变量在程序运行到其作用域之外后被释放。而数组和对象本身在堆中分配，即使程序运行到使用 new 产生数组或者对象的语句所在的代码块之外，数组和对象本身占据的内存不会被释放，数组和对象在没有引用变量指向它的时候，才变为垃圾，不能在被使用，但仍然占据内存空间不放，在随后的一个不确定的时间被GC释放掉。
* 堆可以动态地分配内存大小，生存期也不必事先告诉编译器。但存取速度较慢。

#### 栈

* 用于描述java方法的**内存模型**：每个方法被执行时都会同时创建一个**栈帧**用于存储局部变量表，操作数栈，动态链接，方法出口等信息。每一个方法被调用直至执行完成的过程就对应着一个栈帧在虚拟机中从入栈到出栈的过程。如果线程请求的**栈深度**大于虚拟机所允许的深度就报StackOverflowError。

* 在函数中定义的一些基本类型的变量和对象的引用变量都是在函数的栈内存中分配。

* 当在一段代码块定义一个变量时，Java就在栈中为这个变量分配内存空间，当超过变量的作用域后，Java会自动释放掉为该变量分配的内存空间，该内存空间可以立即被另作它用。

* 栈存取速度比堆要快，但存在栈中的数据大小与生存期必须是确定的。

* 是**线程私有**的内存。

#### 方法区

* 用于存储已被虚拟机加载的**类信息、常量、静态变量、即时编译器编译后的代码**等数据。当方法区无法满足内存分配需求时，会抛出OutOfMemoryError。

* 是**共享**内存。

#### 本地方法栈

* 与虚拟机栈相似，不同的在于它是为虚拟机使用到的Native方法服务的。会抛出StackOverflowError和OutOfMemoryError。

* 是**线程私有**的内存。

#### 程序计数器

* 每个线程都有自己独立的程序计数器，在线程创建时创建，用来指向下一条指令的地址。

* 是**线程私有**的内存。





