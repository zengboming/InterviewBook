# OOM

#### 堆内存的OOM异常

**如何产生？**  
**内存泄漏或占用内存过大**。堆内存用于存储实例对象，当我们不断创建对象，并且对象都有引用指向\(GC Roots到对象之间有可达路径\)，那么垃圾回收机制就不会清理这些对象，当对象多到挤满堆内存的上限后，就产生OOM异常。

模拟堆内存OOM异常：  
PS:在eclipse的Arguments中可以设置VM arguments，这就是JVM的一些参数。  
－Xms：设置堆的最小值  
－Xmx：设置堆的最大值

```
public class A(){
    public static void main(String[] args){
        while(true){
            new Person();
        }
    }
}//运行结果中出现：java.lang.OutOFMemory:Java heap space//说明是在堆内存中发生了OOM异常。
```

**如何解决？**  
使用内存映像分析工具：Eclipse Memory Analyzer对dump出来的堆转储快照进行分析，重点是确认内存中的对象是否是必要的，即要搞明白是内存泄漏还是内存溢出。  
内存泄漏导致的OOM：new出来的很多对象已经不需要了，但仍然有引用指向，所以垃圾回收机制无法回收。  
内存溢出：new出来的对象都是需要的，但堆内存太小装不下了。  
如果是内存泄漏，通过工具查看泄漏对象到GC Roots的引用链。找到泄漏对象是通过怎样的路径与GC Roots发生关联，然后导致垃圾回收机制无法自动回收的。  
如果不存在内存泄漏，也就是所有的对象都必须存在，这时候就调大堆内存。

#### JVM栈和本地方法栈的OOM异常

**StackOverFlowError**  
当线程请求的栈深度大于虚拟机所允许的最大栈深度，就会抛出这个异常。  
**OutOfMemeoryError**  
当虚拟机要扩展栈时无法申请到足够空间的内存，就会抛出这个异常。  
PS：这两种异常其实是对同一个问题的两种描述。在单一线程下，不论是栈帧太大还是虚拟机栈容量太小，当内存无法分配的时候，虚拟机抛出的都是StackOverFlowError。通过测试发现，如果给每个线程的JVM栈分配的内存越大，大的栈帧在这个JVM栈中也能装得下，理应StackOverFlowError会减少，但事实却恰恰相反：当每个线程的JVM栈越大，那么所能创建的线程数就越少，稍微建立几个线程可能就会把有限的内存资源耗尽。

#### 运行时常量池的OOM异常

我们通过String类的intern\(\)方法向方法区中的常量池添加内容。  
intern方法的作用是：当常量池中已经有这个String类型所对应的字符串的话，就返回这个字符串的引用；如果常量池中没有这个字符串的话就将这个字符串添加到常量池中，再返回这个字符串的引用。

#### 方法区的OOM异常

**如何产生？**  
方法区中存放的是Class的相关信息，如：类名、访问修饰符、常量池、字段描述、方法描述等。  
如果产生大量的类就有可能将方法区填满，从而产生方法区的OOM异常。

**注意点**  
方法区的OOM异常是非常常见的，特别是在一些动态生成大量Class的应用中\(JSP\)，需要特别注意类的回收。

本机直接内存的OOM异常

