# OOM

#### 堆内存的OOM异常

**如何产生？**

1. **内存泄漏。**
2. **占用内存过大**。
   1. 堆内存用于存储实例对象，当我们不断创建对象，并且对象都有引用指向\(GC Roots到对象之间有可达路径\)，那么垃圾回收机制就不会清理这些对象，当对象多到挤满堆内存的上限后，就产生OOM异常。
   2. 图片资源加载过多，例如Bitmap
   3. 重复创建View

**如何解决？**

1. **内存泄漏**导致的OOM：new出来的很多对象已经不需要了，但仍然有引用指向，所以垃圾回收机制无法回收。
   1. 通过工具查看泄漏对象到GC Roots的引用链。找到泄漏对象是通过怎样的路径与GC Roots发生关联，然后导致垃圾回收机制无法自动回收的。
   2. try catch finally中将资源回收放到finally语句可以有效避免OOM。
   3. 及时关闭IO对象
2. **内存溢出**导致的OOM：new出来的对象都是需要的，但堆内存太小装不下了。
   1. 调大堆内存。
   2. 避免使用Enum，Enums比静态变量占用两倍以上的内存

   3. 使用更加轻量的数据结构，考虑使用ArrayMap/SparseArray而不是HashMap

   4. 减小Bitmap对象的内存占用，重采样、压缩、使用合适的格式解码

#### JVM栈和本地方法栈的OOM异常

**StackOverFlowError**  
当线程请求的栈深度大于虚拟机所允许的最大栈深度，就会抛出这个异常。  
**OutOfMemeoryError**  
当虚拟机要扩展栈时无法申请到足够空间的内存，就会抛出这个异常。  
J**JVM栈解决办法：**

1. 栈深度溢出的话，可以考虑加大Java虚拟机栈的大小，如果Java虚拟机栈的空间允许的话；

2. 如果由于栈太多，导致OOM，可以考虑适当减小栈的深度（如果可以满足业务需求）来避免；

**本地方法栈解决方法：**

1. 考虑优化程序，减少调用本地方法调用的次数，或者加大调用次数减少内存即可；
2. 加大物理内存；

#### 方法区的OOM异常

**如何产生？**  
方法区中存放的是Class的相关信息，如：类名、访问修饰符、常量池、字段描述、方法描述等。  
如果产生大量的类就有可能将方法区填满，从而产生方法区的OOM异常。

**解决方法**

1.  查看是否其他区域的信息是否放到方法区，如果是，考虑是否可以把他们迁出去；

2. 分析运行时常量池是否占用内存过多，是否有无必要，就算有必要，是否可以用其他的方式代替，比如在堆中分配；

3. 分析不需要的类文件是否过多，是否可以卸载不必要的类文件；



