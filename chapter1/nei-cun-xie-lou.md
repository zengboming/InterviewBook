# 内存泄漏

内存泄漏是指无用对象（不再使用的对象）持续占有内存或无用对象的内存得不到及时的释放，从而造成的内存空间的浪费。

#### 原因

长生命周期的对象持有短生命周期对象的引用就很可能引发内存泄漏，尽管短生命周期对象已经不再需要，但是因为长生命周期对象持有他的引用而导致不能被回收。

#### 例子

1. 静态集合类引起内存泄漏  
   static Vector v = new Vector\(10\);

   最简单的办法就是 v = null;

2. 当集合里面的对象属性被修改后，在调用remove\(\)方法时不起作用。

3. 各种连接，比如数据库连接、网络连接（socket）和IO连接，除非显式的的调用其close\(\)方法将其关闭，否则是不会被GC回收的。

#### 如何查看内存泄漏

1. Eclipse MAT

2. JVisualVM

3. jStat

4. MemoryAnalyzer.exe。java内存泄漏检查工具利器。

   首先我们必须对jvm的堆内存进行dump，只有拿到这个文件我们才能分析出jvm堆内存中到底存了些什么内容，到底在做什么。

#### **如何判断应用程序是否有内存的问题：**

1. **Full GC的频率，时长和效果: **
   如果Full GC频率较高，比如数秒一次，那么此时程序可能就已经出问题了，因为jvm在Full GC的时候是不响应外部请求的。
   如果Full GC时间较长，比如持续数秒，那么此时程序可能就已经出问题了，因为jvm在Full GC的时候是不响应外部请求的。
   如果Full GC之后old 区内存没有显著增加，那么程序很可能有内存泄露问题，并且不久将来可能出现outofmemory异常。
   如果young gc和full gc能够正常发生，且都能有效回收内存，常驻内存区变化不明显，则说明java内存释放情况正常，垃圾回收及时，java内存泄露的几率就会大大降低。但也不能说明一定没有内存泄露。
2. **GC的频率，时长和效果:** 
   如果JVM进行内存回收的频率非常高，比如几乎每数秒中就有一次，每次回收的时间为数秒钟；并且，通过输出还发现每次回收释放的内存非常有限，大多数对象都无法回收。这种现象很大程度上暗示着内存泄漏。\(此时可以用“jmap”来获得当前的一个内存映象，看看哪些对象导致这个问题来找出原因\)
   如果每次GC时间特别长，比如说数十秒，那这种现象很大程度上暗示着内存泄漏。（内存中对象太多，导致遍历时间太长，有时候不好的缓存机制会造成这样的问题）
3. **常驻内存区\(P\)的使用率**: 
   常驻内存如果在应用程序稳定运行较长一段时间后还在持续增长，或者在某段某几段时刻有突变，则有可能有内存问题。（当然很大可能是jvm/app[**server**](javascript:;)配置问题） 如果P始终停留在某个值，说明常驻内存没有突变，比较正常。



