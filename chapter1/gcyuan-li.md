# 垃圾回收机制（GC）

#### GC原理

JAVA中的对象是通过new或反射的方法创建的，这些对象的创建都是在堆（Heap）中分配的，所有对象的回收都是由JAVA虚拟机通过垃圾回收机制完成的。GC为了能正确释放对象，会监控每个对象的运行状况，对他们的申请、引用、被引用、赋值等情况进行监控，JAVA会使用有向图的方式进行管理内存，实时监控对象是否可以达到，如果“不可达”，则将其回收，这样也可以消除引用循环的问题。

#### 按代GC机制

垃圾回收器会在下面两种前提成立的情况下被创建：

1. 大多数对象会很快变得不可达
2. 只有很少的由老对象（创建时间较长的对象）指向新生对象的引用

HotSpot虚拟机将其物理上划分为新生代（young generation）、老年代（old generation）和持久代（ permanent generation ）

1. **新生代**（young generation）

   三个空间：  
   1.  一个伊甸园空间（Eden ）  
   2.  两个幸存者空间（S0，S1）（Survivor ）

   Eden和Survivor内存大小默认8：1，即新生代为10M时，默认Eden 8M，S0 1M, S1 1M。

2. 执行顺序：  
   1. 大多数情况，对象在Eden中分配，当Eden没有足够空间时会触发一个Minor GC。  
   2. 当新生代发生GC时，会将存活的对象移动到其中一个survivor内存区域，并清空Eden区域。  
   3.如果仍然放不下，再次触发minorGC，将存活的对象放到另一个Survivor上，然后清空Eden和那个Survivor区的内存。  
   4. 存活对象会反复在S0，S1之间移动，移动中年龄会自动累加，当GC年龄超过默认阈值15时，就将该对象移动到老年代。

3. **老年代**（old generation）

   老年代用于存放经过几次Minor GC之后依旧存活的对象。当老年代的空间不足时，会触发Major GC / Full GC，速度一般比Minor GC慢10倍以上。

   大对象和长期存活的对象将直接进入老年代。大对象：需要大量连续内存空间的对象，如很长的字符串和数组。长期存活的对象：年龄大于默认15岁的对象。

4. **永久代**（ permanent generation ）

   JDK8之前，类的元数据如方法数据、方法信息、运行时常量池等被保存在永久代中。永久代是方法区的一种实现。

   JDK8中，把永久代从JAVA堆中移除，并把类的元数据保存在本地内存区域（堆外内存），称为元空间。元空间的最大可分配内存就是系统可用内存空间，可避免永久代的内存溢出。

#### 判断对象存活

1. 引用计数法
   在对象上创建一个引用计数器，每当有一个对象引用它时，计数器+1。当使用完该对象时，计数器-1，计数器为0的对象表示不可能在被使用。
   算法简单，判定高效，但无法解决对象互相引用的情况。
2. 可达性分析法  
   通过一系列称为“GC Roots” 的对象作为起点，从这些节点开始向下搜索，搜索路径称为“引用链”，当一个对象到GC Roots没有任何引用链时，意味着该对象可以被回收。  
   在可达性分析中，判断一个对象是否可回收，至少要经历两次标记过程：

   1） 如果对象到GC Roots没有引用链，则进行第一次标记。

   2） 如果对象重写了finalize\(\)方法，且未执行过，那么对象会被插到F-Queue队列中，GC会对队列中的对象进行第二次标记，如果对象在finalize\\(\\)方法中与引用链上的任何一个对象建立联系，那么在第二次标记时，对象会被移出“即将回收”集合。

   以下对象可作为GC Roots:  
   1. 本地变量表中引用的对象。  
   2. 方法区中静态变量引用的对象。  
   3. 方法区中常量引用的对象。  
   4. Native方法引用的对象。

#### 垃圾收集算法

1. 标记-清除算法
   对待回收的对象进行标记，在标记完成后统一回收所有被标记的对象。算法缺点：标记和清除过程效率都很低，收集之后会产生大量的内存碎片，不利于大对象的分配。主要用于老年代。
2. 复制算法
   复制算法将可用内存划分为成大小相等的两块A和B，每次只使用其中一块，当A的内存用完之后，就把存活的对象复制到B，并清空A的内存，不仅提高了标记的效率（只需要标记存活的对象），同时也避免了内存碎片问题，代价是可用内存缩小为原来的一半。一般用于新生代。一般是将内存分为一块较大的Eden空间和两块较小的Survivor空间。HotSpot虚拟机默认比例是8:1,。每次使用Eden和一块Survivor，当回收时将这两块内存中还存活的对象复制到Survivor然后清理掉刚才Eden和Survivor的空间。如果复制过程内存不够使用则向老年代分配担保。
3. 标记-整理算法
   在老年代中，对象存活率较高，复制算法的效率很低。在标记-整理算法中，标记出所有存活的对象，并移动到一端，然后直接清理边界以外的内存。用于老年代。

#### 垃圾收集器

1. **Serial 收集器  **                                            串行GC
   采用**单线程**基于**复制算法**并工作在**新生代**的收集器。进行GC时，必须暂停其他所有的工作线程。是Client模式下新生代默认收集器。
2. **ParNew 收集器     **                                     并行GC
   serial的多线程版本。
3. **Parallel Scavenge收集器**                          并行回收GC
   采用**多线程**基于**复制算法**并工作在**新生代**的收集器。其关注点在于达到一个可控的吞吐量，“吞吐量优先”的收集器。吞吐量 = 用户代码运行时间 / \(用户代码运行时间 + 垃圾收集时间\)。
4. **Parallel Old收集器**                                     并行GC
   采用**多线程**基于**标记-整理**算法并工作在**老年代**的收集器。
5. **Serial Old收集器**                                        串行GC
   采用**单线程**基于**标记-整理**算法并工作在**老年代**的收集器。是Client模式下老年代默认收集器。
6. **CMS 收集器**                                                并发GC
   是一种以**获取最短回收停顿时间**为目标的收集器，工作在**老年代**，基于**标记-清除**算法实现，JDK1.6中当老年代空间使用率达到阈值92%，会触发CMS收集器。整个过程分为4步：
   1. 初始标记：标记GC Roots能够直接关联的对象，会Stop the world
   2. 并发标记：进行GC Roots Tracing的过程，可以和用户线程一起工作。
   3. 重新标记：用于修正并发标记期间由于用户程序继续运行而导致标记产生变动的那部分记录，这个过程会暂停所有线程，单停顿时间远远小于并发标记时间。
   4. 并发清理：可以和用户程序一起工作。

   CMS收集器缺点：1.对CPU资源比较敏感，在并发阶段会占用一部分线程资源，降低系统的总吞吐量。2.无法处理浮动垃圾，在并发清理阶段，用户线程的运行依然会产生新的垃圾对象，这部分垃圾只能在下一次GC时收集。3.收集结束后会造成大量内存碎片，因为基于标记-清除算法实现。
7. **G1 收集器  **  
   基于**标记-整理算**法工作在**新生代和老年代**的收集器。在收集结束后可以避免内存碎片化问题。
   G1优点：
   1. 并行与并发：充分利用多CPU来缩短stop the world停顿时间。
   2. 分代收集：采用不同的方式处理新建的对象、已经存活一段时间和经历多次GC的对象，获得更好的收集效果。
   3. 空间整合：与CMS不同，G1不会产生内存碎片，有利于应用的长时间运行，且分配大对象时，不会导致由于无法申请到足够大的连续内存二提前触发Full GC.
   4. 停顿预测：可以建立可预测的停顿时间模型，能让使用者明确指定在M毫秒的时间片段内，小号在垃圾收集上的时间不得超过N毫秒。

   使用G1收集器时，JAVA堆内存和其他收集器有很大区别，整个JAVA堆会被划分为多个大小相等的独立区域Region，新生代和老年代不再是物理隔离了，都是一部分Region的集合。G1维护了一个优先列表，根绝允许的收集时间，优先回收价值最大的Region，确保了G1可以在有限的时间内尽可能收集更多的垃圾。每个Region一个Remenbered set保存引用关系，避免全堆扫描。

#### GC交互

JAVA有四种引用类型：StrongReference、SoftReference、WeakReference和 PhantomReference

1. SoftReference
   只有当内存不够的时候，才进行回收这类内存，因此在内存足够的时候，它们通常不被回收。适合某些缓存应用。
2. WeakReference
   Weak引用对象更容易、更快被 GC回收。GC运行时，必回收。
3. PhantomReference
   主要用于辅助 finalize函数的使用。它是最弱的一种引用关系，也无法通过PhantomReference取得对象的实例。仅用来当该对象被回收时收到一个通知。
4. StrongReference

   Java 的默认引用实现, 它会尽可能长时间的存活于 JVM 内，当没有任何对象指向它时将会被GC回收。

#### GC调优

在设计GC的时候，就必须在停顿时间和回收率之间进行权衡。

**Stop-the-world**

Stop-the-world意味着JVM因为要执行GC而停止了应用程序的执行。当Stop-the-world发生时，除了GC所需的线程以外，所有线程都处于等待状态，直到GC任务完成。GC优化很多时候就是指减少Stop-the-world发生的时间。

#### Minor GC

MinorGC MinorGC 指发生在新生代的垃圾收集动作，非常频繁，回收速度也快。一般发生在新生代空间不足时,另外一个FullGC经常会伴随至少一次的Minor GC. 当虚拟检测晋升到到老年代的平均大小是否小于老年代剩余空间大小,如果小于并且允许担保失败,则执行Minor GC.

#### Full GC

FullGC 一般是发生在老年代的GC，出现一个FullGC经常会伴随至少一次的Minor GC。速度比MinorGC慢10倍以上。

FULL GC发生的情况:

1. 老年代空间不足 
   老年代空间只有在新生代对象转入及创建为大对象、大数组时才会出现不足的现象，当执行Full GC后空间仍然不足，则抛出如下错误：java.lang.OutOfMemoryError: Java heap space . 措施:为避免以上两种状况引起的FullGC，调优时应尽量做到让对象在Minor GC阶段被回收、让对象在新生代多存活一段时间及不要创建过大的对象及数组。
2. Permanet Generation\(方法区或永久代\)空间满 
   PermanetGeneration中存放的为一些class的信息等，当系统中要加载的类、反射的类和调用的方法较多时，Permanet Generation可能会被占满，在未配置为采用CMS GC的情况下会执行Full GC。如果经过Full GC仍然回收不了，那么JVM会抛出如下错误信息： java.lang.OutOfMemoryError: PermGen space 措施:为避免Perm Gen占满造成Full GC现象，可采用的方法为增大Perm Gen空间或转为使用CMS GC。 
3. CMS GC时出现promotion failed和concurrent mode failure 
   对于采用CMS进行老年代GC的程序而言，尤其要注意GC日志中是否有promotion failed和concurrent mode failure两种状况，当这两种状况出现时可能会触发Full GC。 promotion failed是在进行Minor GC时，survivor space放不下、对象只能放入老年代，而此时老年代也放不下造成的； concurrent mode failure: CMS在执行垃圾回收时需要一部分的内存空间并且此刻用户程序也在运行需要预留一部分内存给用户程序，如果预留的内存无法满足程序需求就出现一次"Concurrent mod failure",并触发一次Full GC。 应对措施为：增大survivor space、老年代空间或调低触发并发GC的比率。
4. 统计得到的Minor GC晋升到旧生代的平均大小大于旧生代的剩余空间 
   Hotspot为了避免由于新生代对象晋升到旧生代导致旧生代空间不足的现象，在进行Minor GC时，做了一个判断，如果之前统计所得到的Minor GC晋升到旧生代的平均大小大于旧生代的剩余空间，那么就直接触发Full GC。如果小于并且不允许担保失败也会发生一次Full GC



