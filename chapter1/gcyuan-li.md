# 垃圾回收机制（GC）

#### GC原理

JAVA中的对象是通过new或反射的方法创建的，这些对象的创建都是在堆（Heap）中分配的，所有对象的回收都是由JAVA虚拟机通过垃圾回收机制完成的。GC为了能正确释放对象，会监控每个对象的运行状况，对他们的申请、引用、被引用、赋值等情况进行监控，JAVA会使用有向图的方式进行管理内存，实时监控对象是否可以达到，如果“不可达”，则将其回收，这样也可以消除引用循环的问题。

在JAVA中，判断一个内存空间是否符合垃圾收集的标准有两个。一个是给对象赋予了Null，以下再没调用过；另一个是给对象赋予了新值，这样重新分配了内存空间。

#### 按代GC机制

垃圾回收器会在下面两种前提成立的情况下被创建：

1. 大多数对象会很快变得不可达
2. 只有很少的由老对象（创建时间较长的对象）指向新生对象的引用

HotSpot虚拟机将其物理上划分为新生代（young generation）、老年代（old generation）和持久代（ permanent generation ）

1. **新生代**（young generation）  
   绝大多数最新被创建的对象会被分配到这里，由于大部分对象在创建后会很快变得不可到达，所以很多对象被创建在新生代，然后消失。对象从这个区域消失的过程：”minor GC“。

   三个空间：  
   1. 1. 一个伊甸园空间（Eden ）  
      2. 两个幸存者空间（Survivor ）

   执行顺序：  
   1. 绝大多数刚刚被创建的对象会存放在伊甸园空间。  
   2. 在伊甸园空间执行了第一次GC之后，存活的对象被移动到其中一个幸存者空间。  
   3. 此后，在伊甸园空间执行GC之后，存活的对象会被堆积在同一个幸存者空间。  
   4. 当一个幸存者空间饱和，还在存活的对象会被移动到另一个幸存者空间。之后会清空已经饱和的幸存者空间。  
   5. 在以上的步骤中重复几次依然存活的对象，就会被移动到老年代。

2. **老年代**（old generation）
   对象没有变得不可达，并且从新生代中存活下来，会被拷贝到这里。其所占用的空间要比新生代多。也正由于其相对较大的空间，发生在老年代上的GC要比新生代少得多。对象从老年代中消失的过程：”major GC“。
   老年代空间的GC事件基本上是在空间已满时发生。
3. **持久代**（ permanent generation ）又叫方法区

   用来保存类常量以及字符串常量。这个区域也可能发生GC。并且发生在这个区域上的GC事件也为major GC。

#### GC类型

1. Serial GC                                              单线程的（标记-清除）
2. Parallel GC                                           多线程的
3. Parallel Old GC                                    多线程的（标记-汇总-压缩）
4. Concurrent Mark & Sweep GC           停顿时间短，占用更多的内存和CPU
5. Garbage First \(G1\) GC                        

#### GC交互

三种引用类：SoftReference、WeakReference和 PhantomReference

1. SoftReference
   只有当内存不够的时候，才进行回收这类内存，因此在内存足够的时候，它们通常不被回收。
2. WeakReference
   Weak引用对象更容易、更快被 GC回收。GC运行时，必回收。
3. PhantomReference
   主要用于辅助 finalize函数的使用。

#### GC调优

在设计GC的时候，就必须在停顿时间和回收率之间进行权衡。

**Stop-the-world**

Stop-the-world意味着JVM因为要执行GC而停止了应用程序的执行。当Stop-the-world发生时，除了GC所需的线程以外，所有线程都处于等待状态，直到GC任务完成。GC优化很多时候就是指减少Stop-the-world发生的时间。

