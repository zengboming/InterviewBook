### 同步

**同步和异步关注的是消息通信机制。**

就是在发出一个调用时，在没有得到结果之前，该调用就不返回。但是一旦调用返回，就得到返回值了。（调用者一直等待调用结果）

### 异步

调用在发出之后，这个调用就直接返回了，所以没有返回结果。但是等待调用的事件被处理完之后在通知调用者。

### 阻塞

阻塞和非阻塞关注的是程序等待调用结果时的状态。

1. 阻塞：阻塞调用是指调用结果返回之前，当前线程会被挂起。函数只有在得到结果之后才会返回。
2. 非阻塞：指调用在不能立刻得到结果之前，该调用不会阻塞当前线程，而是立即返回。



**同步阻塞IO：**

用户进程在发起一个IO操作以后，必须等待IO操作的完成，只有当真正完成了IO操作以后，用户进程才能运行。[**Java**](http://lib.csdn.net/base/javase)传统的IO模型属于此种方式！  
**同步非阻塞IO:**  
在此种方式下，用户进程发起一个IO操作以后边可返回做其它事情，但是用户进程需要时不时的询问IO操作是否就绪，这就要求**用户进程不停的去询问**，从而引入不必要的CPU资源浪费。其中目前JAVA的NIO就属于同步非阻塞IO。  
  
**异步阻塞IO：**  
此种方式下是指应用发起一个IO操作以后，不等待内核IO操作的完成，等内核完成IO操作以后会通知应用程序，这其实就是同步和异步最关键的区别，同步必须等待或者主动的去询问IO是否完成，那么为什么说是阻塞的呢？因为此时是通过select系统调用来完成的，而select函数本身的实现方式是阻塞的，而采用select函数有个好处就是它可以同时监听多个文件句柄，从而提高系统的并发性！  
**异步非阻塞IO:**  
在此种模式下，用户进程只需要发起一个IO操作然后立即返回，等IO操作真正的完成以后，应用程序会得到IO操作完成的通知，此时用户进程只需要对数据进行处理就好了，不需要进行实际的IO读写操作，因为真正的IO读取或者写入操作已经由内核完成了。目前Java中还没有支持此种IO模型。

