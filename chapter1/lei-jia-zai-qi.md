# 类加载器

类加载器是一个重要的 Java 运行时系统组件，它负责在运行时查找和装入类文件中的类。

#### 类加载器类型

1. 引导类加载器（Bootstrap ClassLoader）

   负责加载java基础类，主要是 %JRE\_HOME/lib/目录下的rt.jar、resources.jar、charsets.jar等。

2. 扩展类加载器（Extension ClassLoader）

   负责加载java扩展类，从 java.ext.dirs 系统属性所指定的目录中加载类库，它的父加载器是 Bootstrap。

3. 系统加载器（App ClassLoader）

   负责加载当前java应用的classpath中的所有类。又叫应用类加载器，其父类是Extension。它是应用最广泛的类加载器。它从环境变量 classpath 或者系统属性 java.class.path 所指定的目录中记载类。

4. 用户自定义类加载器（java.lang.ClassLoader的子类）

   它的父加载器是系统加载器。

#### 类加载的过程

![](/assets/11import.png)

在Java中，类装载器把一个类装入JVM中，要经过以下步骤：

\(1\) 装载：查找和导入Class文件；

\(2\) 链接：把类的二进制数据合并到JRE中；

\(a\)校验：检查载入Class文件数据的正确性；

\(b\)准备：给类的静态变量分配存储空间；

\(c\)解析：将符号引用转成直接引用；

\(3\) 初始化：对类的静态变量，静态代码块执行初始化操作

1. 加载  
   将类的.class文件中的二进制数据**读入到内存**中，将其放在运行时数据区的**方法区**内，然后在堆区创建一个java.lang.Class对象，用来封装类在方法区内的数据结构。类的加载的最终产品是位于**堆**区中的Class对象，提供了访问方法区内的数据结构的**接口**。

   1. 通过一个类的全限定名称来获取定义此类的二进制字节流。

   2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。

   3. 在java堆中生成一个代表这个类的java.lang.Class对象，作为方法区这些数据的访问入口。

2. 验证  
   主要时为了确保class文件的字节流中包含的信息符合当前虚拟机的要求,并且不会危害虚拟机自身的安全.包含四个阶段的验证过程:

   1. **文件格式验证**:保证输入的字节流能够正确地解析并存储在方法区之内,格式上符合描述一个java类型信息的要求。经过该阶段的验证后，字节流才会进入内存的方法区中进行存储，后面的三个验证都是基于方法区的存储结构进行的。

   2. **元数据验证**:字节码语义信息的验证,以保证描述的信息符合**java语言规范**.验证点有:这个类是否有父类等.

   3. **字节码验证**:主要是进行**数据流和控制流分析**,保证被校验类的方法在运行时不会做出危害虚拟机安全的行为.

   4. **符号引用验证**:对**符号引用转化为直接引用**过程的验证.

3. 准备  
   为**类变量分配内存并设置变量的初始值**,这些内存在**方法区**进行分配.

   1. 这时候进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中。
   2. 这里所设置的初始值通常情况下是数据类型默认的零值（如0、0L、null、false等），而不是被在Java代码中被显式地赋予的值。

4. 解析  
   将虚拟机常量池中的符号引用转化为直接引用的过程.解析主要是针对类或接口,字段,类方法,类几口方法四类.

5. 初始化  
   执行静态变量的赋值操作以及静态代码块,完成初识化.初始化过程保证了父类中定义的初始化优先于子类的初始化.但接口不需要执行父类的初始化.

   1. 假如这个类还没有被加载和连接，则程序先加载并连接该类

   2. 假如该类的直接父类还没有被初始化，则先初始化其直接父类

   3. 假如类中有初始化语句，则系统依次执行这些初始化语句

#### 类初始化顺序

1.类从顶至底的顺序初始化，所以声明在顶部的字段的早于底部的字段初始化

2.超类早于子类和衍生类的初始化

3.如果类的初始化是由于访问静态域而触发，那么只有声明静态域的类才被初始化，而不会触发超类的初始化或者子类的

4.初始化即使静态域被子类或子接口或者它的实现类所引用。

5.接口初始化不会导致父接口的初始化。

6.静态域的初始化是在类的**静态初始化**期间，非静态域的初始化时在**类的实例创建**期间。这意味这**静态域初始化在非静态域之前**。

7.**非静态域通过构造器初始化**，子类在做任何初始化之前构造器会隐含地调用父类的构造器，他保证了非静态或实例变量（父类）初始化早于子类

#### 代码执行顺序

1. 多个静态成员变量, 静态代码块按顺序执行

2. 单个类中: 静态代码 -&gt;main方法 -&gt;构造块 -&gt;构造方法

3. 构造块在每一次创建对象时执行

4. 涉及父类和子类的初始化过程  
   1. 初始化父类中的静态成员变量和静态代码块  
   2. 初始化子类中的静态成员变量和静态代码块  
   3. 初始化父类的普通成员变量和构造代码块\(按次序\)，再执行父类的构造方法\(注意父类构造方法中的子类方法覆盖\)  
   4. 初始化子类的普通成员变量和构造代码块\(按次序\)，再执行子类的构造方法

#### JVM加载class文件的机制

JVM 中类的装载是由类加载器（ClassLoader） 和它的子类来实现的，Java 中的类加载器是一个重要的 Java 运行时系统组件，它负责在运行时查找和装入类文件中的类。 由于 Java 的跨平台性，经过编译的 Java 源程序并不是一个可执行程序，而是一个或多个类文件。当 Java 程序需要使用某个类时，JVM 会确保这个类已经被加载、连接\(验证、准备和解析\)和初始化。

**类的加载**是指**把类的 .class 文件中的数据读入到内存中**，通常是创建一个字节数组读入 .class 文件，然后产生与所加载类对应的 Class 对象。加载完成后，Class 对象还不完整，所以此时的类还不可用。

当类被加载后就进入**连接阶段，这一阶段包括验证\(**确保class文件的字节流中包含的信息符合当前虚拟机的要求,并且不会危害虚拟机自身的安全**\)、准备\(为静态变量分配内存并设置默认的初始值\)和解析\(将符号引用替换为直接引用\)**三个步骤。

最后 JVM 对类进行**初始化**，包括：1. 如果类存在直接的父类并且这个类还没有被初始化，那么就先初始化父类；2. 如果类中存在初始化语句，就依次执行这些初始化语句。

#### 双亲委派机制（PDM）

类加载过程采取了双亲委托机制\(PDM\)。PDM 更好的保证了 Java 平台的安全性。

**双亲委派模型的工作原理**是:如果一个类加载器受到了类加载请求,它首先不会自己去尝试加载这个类,而把这个请求委派给父类加载器去完成,每一层次的类加载器都是如此,因此所有的加载请求最终都应该传送到顶层的启动类加载器中,只有当父类加载器反馈自己无法完成加载请求时,加载器才尝试自己加载.这种方式保证了Object类在各个加载器加载环境中都是同一个类。

