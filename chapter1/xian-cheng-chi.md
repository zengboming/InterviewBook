# 线程池

![](/assets/threadpool.png)

#### 为什么要使用线程池

1.  避免频繁地创建和销毁线程，达到线程对象的重用。（创建和销毁线程的开销还是很大的）
2. 使用线程池还可以根据项目灵活地控制并发的数目。

#### 线程池实现原理

**预先启动一些线程，线程无限循环从任务队列中获取一个任务进行执行，直到线程池被关闭。如果某个线程因为执行某个任务发生异常而终止，那么重新创建一个新的线程而已。如此反复。**线程池的作用是有效的降低频繁创建销毁线程所带来的额外开销。一般来说,线程池都是采用预创建的技术,在应用启动之初便预先创建一定数目的线程。应用在运行的过程中,需要时可以从这些线程所组成的线程池里申请分配一个空闲的线程,来执行一定的任务,任务完成后,并不是将线程销毁,而是将它返还给线程池,由线程池自行管理。如果线程池中预先分配的线程已经全部分配完毕,但此时又有新的任务请求,则线程池会动态的创建新的线程去适应这个请求，但线程的数目永远不会超过最大值。超过最大值的线程可以排队,但他们要等到其他线程完成后才启动。当然,有可能,某些时段应用并不需要执行很多的任务,导致了线程池中的线程大多处于空闲的状态,为了节省系统资源,线程池就需要动态的销毁其中的一部分空闲线程。因此,线程池都需要一个管理者,按照一定的要求去动态的维护其中线程的数目。线程池将频繁创建和销毁线程所带来的开销分摊到了每个具体执行的任务上,执行的次数越多,则分摊到每个任务上的开销就越小。当然,如果线程创建销毁所带来的开销与线程执行任务的开销相比微不足道,可以忽略不计,则线程池并没有使用的必要。

#### 线程池结构

1. Workqueue：任务队列，用于存放待执行任务。
2. Worker：工作类，一个worker代表启动了一个线程，它启动后会循环执行workQueue里面的所有任务。

#### 线程池执行流程

1. 一个任务提交，如果线程池大小没达到corePoolSize，则每次都启动一个worker也就是一个线程来立即执行。

2. 如果达到corePoolSize，则把多余的任务放到workQueue，等待已启动的worker来循环执行。

3. 如果队列workQueue都放满了还没有执行，则在maximumPoolSize下面启动新的worker来循环执行workQueue。

4. 如果启动到maximumPoolSize还有任务进来，线程池已达到满负载，此时就执行任务拒绝RejectedExecutionHandler

#### 线程池主要应用场景

1. 需要大量的线程来完成任务，且完成任务的时间比较短，如WEB服务器完成网页请求这样的任务。因为单个任务小，而任务数量巨大。

2. 对性能要求苛刻的应用，比如要求服务器迅速相应客户请求。





