# 线程状态

1. **new（新建）**：一个线程被创建了但未被启动就处于新建状态，即在程序中使用**new MyThread\(\);创建的线程实例就处于此状态**。
2. **runnable（就绪）**：**创建的线程实例调用start\(\)方法后便进入可运行状态**，处于此状态的线程并不是说一定处于运行状态，Java多线程使用的是抢占式调度，每个可运行线程轮着获取CPU时间片，start\(\)方法把线程放进可运行线程池中，CPU按一定规则一个个执行池里的线程。
3. **running（运行）**：**当可运行线程获取到CPU执行时间片即进去了运行状态。**
4. **Waiting/Blocked/Sleep（等待/阻塞/睡眠）**:所谓阻塞状态是正在运行的线程没有运行结束，暂时让出CPU，这时其他处于就绪状态的线程就可以获得CPU时间，进入运行状态。进入此状态的原因有：  
   1. 线程通过调用sleep方法进入睡眠状态；

   1. 线程调用一个在I/O上被阻塞的操作，即该操作在输入输出操作完成之前不会返回到它的调用者；

   2. 线程试图得到一个锁，而该锁正被其他线程持有；

   3. 线程在等待某个触发条件；

5. **dead（死亡）：**线程执行完run\(\)方法实现的任务，或因为异常导致退出任务，线程进入死亡状态后将不可再转换成其他状态。

#### 线程状态转换

1. **睡眠**：
   Thread.sleep\(\)静态方法强制当前正在执行的线程休眠。当线程睡眠时是**睡眠状态**。当睡眠时间到期，则返回到可运行状态。
2. **线程的优先级和线程让步**：
   线程的让步是通过Thread.yield\(\)来实现的。yield\(\)方法的作用是：**暂停当前正在执行的线程对象，并执行其他线程。**JVM线程调度程序是基于优先级的抢先调度机制。在大多数情况下，当前运行的线程优先级将大于或等于线程池中任何线程的优先级。yield\(\)应该做的是让当前运行线程回到**可运行状态**，以允许具有相同优先级的其他线程获得运行机会。因此，使用yield\(\)的目的是让相同优先级的线程之间能适当的轮转执行。但是，实际中无法保证yield\(\)达到让步目的，因为让步的线程还有可能被线程调度程序再次选中。
3. **join\(\)方法**

   **在线程A中调用了线程B的Join\(\)方法，直到线程B执行完毕后，才会继续执行线程A**。。可以将两个交替执行的线程合并为顺序执行的线程。   简单点说就是调用join方法的线程会以加入的方式进入，优先执行完调用join函数的线程才恢复调用join\(\)函数本身所在的线程。



