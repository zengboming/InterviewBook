# Hibernate

### 五大核心接口

1. **Session接口**：负责执行被持久化对象的CRUD操作。但需要注意的是Session对象是非线程安全的。

2. **SessionFactory接口：**负责初始化Hibernate。它充当数据存储源的代理，并负责创建 Session对象。

3. **Configuration接口：**负责配置并启动Hibernate，创建SessionFactory对 象。在Hibernate的启动的过程中，Configuration类的实例首先定位映射文档位置、读取配置，然后创建SessionFactory对象。

4. **Transaction接口：**负责事务相关的操作。

5. **Query和Criteria接口：**负责执行各种数据库查询。它可以使用HQL语言或SQL语句两种表达方式。

### 优点

1. **对象化**：hibernate可以让开发人员以面相对象的思想来操作数据库。jdbc只能通过SQL语句将元数据传送给数据库，进行数据操作。而hibernate可以在底层对元数据和对象进行转化，使得开发者只用面向对象的方式来存取数据即可。

2. **更好的移植性：**hibernate使用xml或JPA的配置以及数据库方言等等的机制，使得hibernate具有更好的移植性，对于不同的数据库，开发者只需要使用相同的数据操作即可，无需关心数据库之间的差异。而直接使用JDBC就不得不考虑数据库差异的问题。

3. **开发效率高**：hibernate提供了大量的封装（这也是它最大的缺点），很多数据操作以及关联关系等都被封装的很好，开发者不需写大量的sql语句，这就极大的提高了开发者的开发效率。

4. **缓存机制的使用**：hibernate提供了缓存机制（session缓存，二级缓存，查询缓存），对于那些改动不大且经常使用的数据，可以将它们放到缓存中，不必在每次使用时都去查询数据库，缓存机制对提升性能大有裨益。

### 缺点

1. 由于对持久层封装过于完整，导致开发人员无法对SQL进行优化，无法灵活使用JDBC的原生SQL，Hibernate封装了JDBC，所以没有JDBC直接访问数据库效率高。要使用数据库的特定优化机制的时候，不适合用Hibernate

2. 框架中使用ORM原则，导致配置过于复杂，一旦遇到大型项目，比如300张表以上，配置文件和内容是非常庞大的，另外，DTO满天飞，性能和维护问题随之而来

3. 如果项目中各个表中关系复杂，表之间的关系很多，在很多地方把lazy都设置false，会导致数据查询和加载很慢，尤其是级联查询的时候。

4. Hibernate在批量数据处理时有弱势，对于批量的修改，删除，不适合用Hibernate,这也是ORM框架的弱点

### Lazy-Load

在Hibernate框架中，当我们要访问的数据量过大时，明显用缓存不太合适， 因为内存容量有限，为了减少并发量，减少系统资源的消耗，这时Hibernate用懒加载机制来弥补这种缺陷，但是这只是弥补而不是用了懒加载总体性能就提高了。我们所说的懒加载也被称为延迟加载，它在查询的时候不会立刻访问数据库，而是返回代理对象，当真正去使用对象的时候才会访问数据库。

1. 通过Session.load\(\)实现懒加载 load：根据id查询。查询返回的是代理对象，不会立刻访问数据库，是懒加载的。当真正去使用对象的时候才会访问数据库。

2. one-to-one\(元素\)实现了懒加载。 在一对一的时候，查询主对象时默认不是懒加载。即：查询主对象的时候也会把从对象查询出来。需要把主对象配制成lazy="true" constrained="true" fetch="select"。此时查询主对象的时候就不会查询从对象，从而实现了懒加载。一对一的时候，查询从对象的是默认是懒加载。即：查询从对象的时候不会把主对象查询出来。而是查询出来的是主对象的代理对象。

3. many-to-one（元素）实现了懒加载。 多对一的时候，查询主对象时默认是懒加载。即：查询主对象的时候不会把从对象查询出来。

4. one-to-many\(元素\)懒加载：默认会懒加载，这是必须的，是重常用的。 一对多的时候，查询主对象时默认是懒加载。即：查询主对象的时候不会把从对象查询出来。



